// ä»Šå¤©æ²’ç©ºæ”¹äº†ï¼Œåˆ©ç”¨DFSä»¥åŠsetçš„ç‰¹æ€§æ›´æ–°å‰ç½®èª²ç¨‹ï¼Œèª²ç¨‹è™•ç†å®Œç•¢æœƒè¢«æ‰“ä¸Šæ¨™ç±¤ä»¥ä¾¿å¾ŒçºŒè™•ç†æ™‚è·³é
// çœ‹åˆ°å¿«çš„å¯«æ³•æ˜¯ä½¿ç”¨Topological Sortingæ›´æ–°è¡¨
// E=prerequisitesé•·åº¦ï¼ŒQ=queriesçš„é•·åº¦ï¼Œğ‘‰=èª²ç¨‹æ•¸ï¼ŒP=èª²ç¨‹é–“å‰ç½®é—œä¿‚æ•¸ç¸½å’Œ
// æ™‚é–“å·®ç•°:æˆ‘çš„=O(E+P^2+Q), åˆ¥äººçš„=O(V^2+E+Q)

class Solution {
private:
    void DFS(unordered_map<int, unordered_set<int>>& course_to_pre, int course, vector<bool>& processed){
        if (processed[course]) return;

        vector<int> to_add; // æš«å­˜å¾…æ’å…¥çš„å‰ç½®èª²ç¨‹
        for(int pre_course : course_to_pre[course]){
            if(!processed[pre_course]){
                DFS(course_to_pre, pre_course, processed);
            }
            for(int add_course : course_to_pre[pre_course]){
                to_add.push_back(add_course);
            }
        }
        // åŠ å…¥
        for(int new_pre_course : to_add){
            course_to_pre[course].insert(new_pre_course);
        }
        processed[course] = true;
    }
public:
    vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {
        unordered_map<int, unordered_set<int>> course_to_pre;
        for(int i= 0; i< prerequisites.size(); i++){
            course_to_pre[prerequisites[i][1]].insert(prerequisites[i][0]);
        }
        vector<bool> processed(numCourses, false);
        // process DFS
        for(int i= 0; i< numCourses; i++){
            DFS(course_to_pre, i, processed);
        }
        // ans
        vector<bool> ans;
        for(int i= 0; i< queries.size(); i++){
            if(course_to_pre[queries[i][1]].find(queries[i][0])!= course_to_pre[queries[i][1]].end()){
                ans.push_back(true);
            }
            else{
                ans.push_back(false);
            }
        }
        return ans;
    }
};
